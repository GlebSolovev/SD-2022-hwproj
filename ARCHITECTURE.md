# Архитектурная документация MyHwProj

## Ключевые требования (aka drivers)

### Функциональные

* < см. постановку дз :( >
* должен быть предоставлен как веб-UI, так и REST API

### Нефункциональные

* система должна представлять собой веб-приложение
* ???

## Use-case-ы

![use case diagram](images/use-case.png)

Тут особо нечего комментировать, вместо этого предлагается взглянуть на макеты экранов по паре use-case-ов (переход слева направо):

1. Студент читает условия задания и посылает решение:
   ![read task and submit](images/hwproj-uc-readTaskAndSubmit.png)
2. Студент смотрит детали по одному из решений:
   ![submission details](images/hwproj-uc-submissionDetails.png)
3. Учитель создает новое задание:
   ![create assignment](images/hwproj-uc-createAssignment.png)

## Общее описание

За основу была взята "чистая архитектура", поскольку она наиболее конкретно описывает, какие именно компоненты стоит иметь и как они должны взаимодействовать. Впрочем, некоторые ее части нам не понадобились: например, Presenter, ViewModel и View для REST-сервиса несут мало смысла. Детали см. ниже.

## Компоненты

![component diagram](images/components.png)

За взаимодействие с пользователем отвечает компонент `IO`. На практике это будет какой-либо HTTP фреймворк, который будет:

1. Принимать запрос от пользователя в том или ином формате (вероятно, HTTP запрос)
1. Преобразовывать его в понятный всей остальной системе класс `RequestModel`
1. Получать обратно ответ в виде класса `ResponseModel`
1. Отправлять пользователю результат запроса в том или ином формате (либо HTML страничка для веб-UI, либо JSON внутри HTTP ответа для REST-сервиса)

Полученные `ResponseModel` передаются в компонент `Interactor`, задача которого довольно проста: по типу запроса определить подходящую `Entity`, способную его выполнить, и просто передать ей этот запрос. Чтобы получить конкретный экземпляр `Entity`, `Interactor` должен воспользоваться `EntityGateway` _(на схеме это отображено как интерфейс, что не совсем корректно, но зато схема не перегружена)_.

У каждого экземпляра `Entity` есть доступ к необходимым для его работы ресурсам: `Storage` и `MessageBroker` (оба опционально; передачей этого доступа занимается `EntityGateway`).

Отдельно от всех вышеперечисленных компонентов существует `Runner`, задача которого ясна: ждать запросы на запуск программ-чекеров в очереди сообщений и эти программы запускать.

## Классы

![class diagram](images/classes.png)

Классы достаточно четко соответствуют компонентам, поэтому нет большого смысла заново рассказывать, что такое, например, `Interactor`. Описание же конкретных методов будет непосредственно в коде, да и к тому же названия, как правило, говорят сами за себя. Поэтому здесь будут описаны только детали.

* Как говорилось ранее, классы `IO` должны обслуживать ввод-вывод пользователя. С одной стороны, хочется разделить `RESTIO` и `HTMLIO` на два раздельных класса, так как у них внутри будет разная логика представления информации. С другой стороны, фреймворк может продиктовать какие-либо ограничения на то, насколько сильно можно отделить ввод-вывод на разных endpoint-ах (или наоборот, фреймворк сможет выполнять преобразование в `RequestModel` "из коробки", что сделает создание отдельного класса для `IO` бессмысленным). Получается, что в зависимости от выбранных технологий классы `IO` могут оказаться очень крупными - как два отдельных сервера, а могут оказаться пустыми фасадами, не делающими буквально ничего. По этой причине у классов `RESTIO` и `HTMLIO` нет конкретных полей и методов.

* `RequestModel`, `ResponseModel`, `Entity` - это интерфейсы или абстрактные классы, имеющие реализации для каждого конкретного запроса пользователя. _На каждый запрос требуется существенно больше кода, чем хотелось бы, но лучше мы не придумали..._

* `Storage` - это интерфейс для хранения данных. Различные реализации могут использовать различные БД или что угодно еще - это существенно облегчит жизнь при тестировании. Никакого конкретного интерфейса тут не указано, поскольку с очень высокой вероятностью на практике для доступа к БД будет использован тот или иной ORM, и тогда интерфейс станет ясен сам собой.

* Компонент `MessageBroker` делится на два интерфейса: один посылает в очередь сообщений просьбу запустить программу-чекер (`EntityMessageBroker`), а другая эти просьбы получает и посылает результат выполнения чекера назад (`RunnerMessageBroker`). Осмысленно оба эти интерфейса реализовать в одном классе, заточенном на работу с конкретной технологией. Стоит отметить: в зависимости от конкретных возможностей RabbitMQ вполне возможны изменения в этих интерфейсах.

* После выполнения программы-чекера требуется записать результат выполнения в `Storage`, однако `Runner` находится в другом процессе или даже на другой машине. Чтобы получить доступ к `Storage`, сообщения о готовности содержат callback, который должен быть выполнен в `EntityMessageBroker` при получении такого обратного соообщения.

* `AssignmentResponse`, `SubmissionResponse`, `CheckResultResponse` - это дата-классы, на самом деле тесно связанные с представлением данных предметной области (см. ER-диаграмму далее), но тем не менее имеющие свой смысл: они содержат только ту информацию, которую мы хотим послать в ответе на запрос. Впрочем, вполне возможно, что конкретный ORM (см. пункт про `Storage`) внесет какие-либо изменения в эти классы. Аналогично классы `SubmissionCheckTask` и `SubmissionCheckResult` являются дата-классами для пересылки через очередь сообщений, и точно так же могут измениться в процессе реализации.

## Последовательность действий

Чтобы показать взаимодействия между классами, приведем в качестве примера диаграмму последовательностей для конкретного сценария: студент присылает решение некоторой задачи (`SubmitSubmissionRequest`).

![sequence diagram](images/sequence.png)

Диаграмма не очень строго соответствует UML:

* бледно-серая линия разграничивает основное приложение и раннеров
* на цельных стрелках написан вызываемый метод, на пунктирных - возвращаемый объект

## Схема данных

На закуску - простенькая ER-диаграмма, отображающая представление данных, которые требуется сохранять на сервере.

![er diagram](images/er.png)

* `Assignment.taskText` мог бы быть и PDF-файлом, но мы подумали, что это излишнее усложнение. В конце концов, преподаватель может вместо текста условия просто вставить ссылку на документ.
* `Submission.submissionLink` является ссылкой, а не просто строкой, есть смысл добавить на это проверку (об этом комментарий "typecheck" на схеме).
* В нашем понимании ТЗ, студент посылает в качестве решения именно ссылку на гитхаб, и программа-чекер принимает на вход именно ссылку.
* Как видно, в `Assignment.checkerProgram` хранится именно исполняемый бинарник. Это вызывает два вопроса:
  * Кроссплатформенность. Ответ - договоримся, что чекеры пишутся под Linux (или же являются сжатым кодом Python). В будущем при необходимости можно добавить возможность для преподавателя указать платформу, а `Runner` будет использовать один из Docker-контейнеров.
  * Интерфейс для чекера. Ответ - пусть все необходимые данные передаются через аргументы консоли, в каком именно порядке - неважно для архитектуры.
